<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>P111 API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>P111</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import numpy as np
from typing import List, Callable



def matrix_multiplication(m_1: np.ndarray, m_2: np.ndarray) -&gt; np.ndarray :
    &#34;&#34;&#34;
    Función que recibe dos matrices numpy de dimensiones compatibles y realiza 
    una multiplicacion entre ambas.
    
    Args:
        m_1: Matriz 1 
        m_2: Matriz 2
    
    Return: 
        result: Matriz resultante de multiplicar la matriz 1 con la matriz 2
    &#34;&#34;&#34;
    result = np.zeros((len(m_1),len(m_1)))
    
    for i in range(len(m_1)):

        for j in range(len(m_2[0])):

            for k in range(len(m_2)):
                result[i][j] += m_1[i][k] * m_2[k][j]

    return result



def rec_bb(t: list, f: int, l: int, key: int) -&gt; int :
    &#34;&#34;&#34;
    Función que recibe una lista con su primer y último indice, asi como una clave a buscar y
    aplica una versión recursiva de la búsqueda binaria para encontrar la posición
    de la clave(key) entre el indice primero(first) y el indiice último(last).
    
    Args:
        t: Lista sobre la que se buscará la clave
        f: Primer índice
        l: Último índice
        key: Clave a buscar

    
    Return: 
        Si encuentra la clave devuelve el índice donde es encontrado, de no encontrarse 
        la clave devuelve None.
    &#34;&#34;&#34;
    if l&gt;=f:

        mid = (f+l) // 2

        if t[mid] == key:
            return mid
        
        elif t[mid] &lt; key:
            return rec_bb(t, mid+1, l, key)

        else:
            return rec_bb(t, f, mid-1, key)

    else:
        return None



def bb(t: list, f: int, l: int, key: int) -&gt; int :
    &#34;&#34;&#34;
    Versión iterativa de la función rec_bb.

    Args:
        t: Lista sobre la que se buscará la clave
        f: Primer índice
        l: Último índice
        key: Clave a buscar

    
    Return: 
        Si encuentra la clave devuelve el índice donde es encontrado, de no encontrarse 
        la clave devuelve None.
    &#34;&#34;&#34;

    while f &lt;= l:

        mid = (f+l) // 2

        if t[mid] == key:
            return mid

        elif t[mid] &lt; key:
            f = mid + 1

        elif t[mid] &gt; key:
            l = mid -1
    
    return None

def min_heapify(h: np.ndarray, i: int):
    &#34;&#34;&#34;
    Función que recibe un array de numpy aplica heapify sorbre el elemento situado en el índice indicado como argumento.
    Esto es que dado un nodo se asegura que el subárboll desde ese nodo es un min heap.

    Args:
        h: Array numpy que contiene el nodo sobre el que se quiere realizar el heapify
        i: Índice del nodo sobre el que se quiere realizar heapify
    &#34;&#34;&#34;
    # Mientras no estes en el nodo hoja
    while 2*i+1 &lt; len(h):
        n_i = i

        # Si nodo enviado &gt; que hijo izquierdo entonces guardas posicion hijo
        if h[i] &gt; h[2*i+1]:
            n_i = 2*i+1

        #Comprueba si hay hijo derecho y si lo hay comprueba nodo estamos &gt; derecho y si posicion guardada es &gt; hijo derecho, si ambos son mayores se actualiza posicion&#34;&#34;&#34;
        if 2*i+2 &lt; len(h) and h[i] &gt; h[2*i+2] and h[2*i+2] &lt; h[n_i]:
            n_i = 2*i+2

        #Si no hijo izq y drc es menor, y nodo que hemos guardado tiene valor menor o posicion baja, intercambia valores de i y n_i&#34;&#34;&#34;
        if n_i &gt; i:
            h[i], h[n_i] = h[n_i], h[i]
            i = n_i

        #Si no hace nada, devuelve
        else:
            return


def insert_min_heap(h: np.ndarray, k: int) -&gt; np.ndarray:
    &#34;&#34;&#34;
    Función que inserta en el min heap pasado por argumento un elemento.

    Args:
        h: Min heap en el que se quiere insertar el elemento
        k: Elemento que se quiere insertar en el min heap

    Return:
        h: Min heap con el nuevo elemento insertado.
        Si el min heap pasado por argumento se encuentra vacio o es None se devuelve
        un array numpy que contenga el elemento k.
    &#34;&#34;&#34;

    #Comprobación&#34;&#34;&#34;
    if h is None or len(h) &lt; 1: 
        return [k]

    #primero añade el elemento al heap&#34;&#34;&#34;
    h = np.append(h,k)
    j = len(h) - 1

    #coloca el elemento en su lugar correspondiente&#34;&#34;&#34;
    while j &gt;= 1 and h[(j-1) // 2] &gt; h[j]:
        h[(j-1) // 2], h[j] = h[j], h[(j-1) // 2]
        j = (j-1) // 2
    
    return h
    

def create_min_heap(h: np.ndarray):
    &#34;&#34;&#34;
    Función que crea un min heap sobre el array numpy pasado por argumento.

    Args:
        h: Array numpy sobre el que se quiere crear el min heap
    &#34;&#34;&#34;

    #realiza un heapify de los padres de todos los subarboles de abajo arriba&#34;&#34;&#34;
    k = (len(h)-1)//2
    while k &gt;= 0:
        min_heapify(h, k)
        k-=1
    return
    

def pq_ini() -&gt; np.ndarray:
    &#34;&#34;&#34;
    Inicializa una cola de prioridad vacía

    Return:
        q: Cola de proiridad vacía
    &#34;&#34;&#34;

    q = []
    return q

def pq_insert(h: np.ndarray, k: int)-&gt; np.ndarray:
    &#34;&#34;&#34;
    Función que inserta el elemento pasado por argumento en la cola de prioridad y devuelve 
    la nueva cola

    Args:
        h: Cola en la que se quiere insertar el elemento
        k: Elemento a insertar

    Return:
        Cola de proiridad vacía
    &#34;&#34;&#34;
    
    return insert_min_heap(h, k)

def pq_remove(h: np.ndarray)-&gt; np.ndarray:
    &#34;&#34;&#34;
    Función que elimina el elemento con el menor valor de prioridad de la cola de prioridad pasada por 
    argumento.

    Args:
        h: Cola de prioridad de la que se quiere eliminar el elemento con menor valor de prioridad

    Return:
        Devuelve el elemento eliminado y la nueva cola. 
        Si la cola pasada por argumento está vacía devuelve None

    &#34;&#34;&#34;
    #Comprobación
    if h is None or len(h) == 0: return None
    
    elim = h[0]
    h = np.delete(h,0)
    min_heapify(h,0)
    return elim, h


def select_min_heap(h: np.ndarray, k: int)-&gt; int:
    &#34;&#34;&#34;
    Función que devuelve el elemento en la posición K pasada por argumento si el array pasado 
    por argumento estuviera estuveira ordenado de menor a mayor
    ejemplo: array = [3,1,2,4,5] ordenado = [1,2,3,4,5] K = 2 entonces numero = 2
    
    Args:
        h: Array del que se quiere obtener el elemento en la posición K de estar ordenado de menor a mayor
        k: Posición dentro del array ordenado

    Return:
        Elemento en la posición K dentro del array ordenado

    &#34;&#34;&#34;
    aux = h.copy()
    # invierte el array 
    aux = np.multiply(aux, -1)
    # se cogen los k primeros
    aux_mh = aux[:k]
    
    # realiza el create_min_heap sobre el array invertido
    create_min_heap(aux_mh)

    for i in range (k, len(h)):
        if aux[i] &gt; aux_mh[0]:
            aux_mh[0] = aux[i]
            min_heapify(aux_mh, 0)
    
    return aux_mh[0]*-1


def obtiene_menores(h: np.ndarray)-&gt; np.ndarray:
    &#34;&#34;&#34;
    Función que encuentra los 2 menores elemento dentro del array pasado por argumento

    Args: 
        h: Array del que se quieren encontrar los 2 menores elementos
    
    Return:
        Array que contiene los dos menores elementos.
        Si el array tiene 2 o menos elementos se devuelven esos elementos.
        Si el array pasado por argumento está vacío devuelve None.
    &#34;&#34;&#34;

    # si el array tiene 2 o menos elementos se devuelven estos
    if len(h) == 1 or len(h) == 2: return h

    # si esta vacio se devuelve None
    if len(h) == 0 or h is None: return None

    m1 = h[0]
    m2 = h[1]
    for i in range(2, len(h)):
        if m1 &gt; h[i] or m2 &gt; h[i]:
            if m1 &gt; m2:
                m1 = h[i]
            else:
                m2 = h[i]

    return [m1,m2]</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="P111.bb"><code class="name flex">
<span>def <span class="ident">bb</span></span>(<span>t: list, f: int, l: int, key: int) ‑> int</span>
</code></dt>
<dd>
<div class="desc"><p>Versión iterativa de la función rec_bb.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>t</code></strong></dt>
<dd>Lista sobre la que se buscará la clave</dd>
<dt><strong><code>f</code></strong></dt>
<dd>Primer índice</dd>
<dt><strong><code>l</code></strong></dt>
<dd>Último índice</dd>
<dt><strong><code>key</code></strong></dt>
<dd>Clave a buscar</dd>
</dl>
<p>Return:
Si encuentra la clave devuelve el índice donde es encontrado, de no encontrarse
la clave devuelve None.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def bb(t: list, f: int, l: int, key: int) -&gt; int :
    &#34;&#34;&#34;
    Versión iterativa de la función rec_bb.

    Args:
        t: Lista sobre la que se buscará la clave
        f: Primer índice
        l: Último índice
        key: Clave a buscar

    
    Return: 
        Si encuentra la clave devuelve el índice donde es encontrado, de no encontrarse 
        la clave devuelve None.
    &#34;&#34;&#34;

    while f &lt;= l:

        mid = (f+l) // 2

        if t[mid] == key:
            return mid

        elif t[mid] &lt; key:
            f = mid + 1

        elif t[mid] &gt; key:
            l = mid -1
    
    return None</code></pre>
</details>
</dd>
<dt id="P111.create_min_heap"><code class="name flex">
<span>def <span class="ident">create_min_heap</span></span>(<span>h: numpy.ndarray)</span>
</code></dt>
<dd>
<div class="desc"><p>Función que crea un min heap sobre el array numpy pasado por argumento.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>h</code></strong></dt>
<dd>Array numpy sobre el que se quiere crear el min heap</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_min_heap(h: np.ndarray):
    &#34;&#34;&#34;
    Función que crea un min heap sobre el array numpy pasado por argumento.

    Args:
        h: Array numpy sobre el que se quiere crear el min heap
    &#34;&#34;&#34;

    #realiza un heapify de los padres de todos los subarboles de abajo arriba&#34;&#34;&#34;
    k = (len(h)-1)//2
    while k &gt;= 0:
        min_heapify(h, k)
        k-=1
    return</code></pre>
</details>
</dd>
<dt id="P111.insert_min_heap"><code class="name flex">
<span>def <span class="ident">insert_min_heap</span></span>(<span>h: numpy.ndarray, k: int) ‑> numpy.ndarray</span>
</code></dt>
<dd>
<div class="desc"><p>Función que inserta en el min heap pasado por argumento un elemento.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>h</code></strong></dt>
<dd>Min heap en el que se quiere insertar el elemento</dd>
<dt><strong><code>k</code></strong></dt>
<dd>Elemento que se quiere insertar en el min heap</dd>
</dl>
<h2 id="return">Return</h2>
<p>h: Min heap con el nuevo elemento insertado.
Si el min heap pasado por argumento se encuentra vacio o es None se devuelve
un array numpy que contenga el elemento k.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def insert_min_heap(h: np.ndarray, k: int) -&gt; np.ndarray:
    &#34;&#34;&#34;
    Función que inserta en el min heap pasado por argumento un elemento.

    Args:
        h: Min heap en el que se quiere insertar el elemento
        k: Elemento que se quiere insertar en el min heap

    Return:
        h: Min heap con el nuevo elemento insertado.
        Si el min heap pasado por argumento se encuentra vacio o es None se devuelve
        un array numpy que contenga el elemento k.
    &#34;&#34;&#34;

    #Comprobación&#34;&#34;&#34;
    if h is None or len(h) &lt; 1: 
        return [k]

    #primero añade el elemento al heap&#34;&#34;&#34;
    h = np.append(h,k)
    j = len(h) - 1

    #coloca el elemento en su lugar correspondiente&#34;&#34;&#34;
    while j &gt;= 1 and h[(j-1) // 2] &gt; h[j]:
        h[(j-1) // 2], h[j] = h[j], h[(j-1) // 2]
        j = (j-1) // 2
    
    return h</code></pre>
</details>
</dd>
<dt id="P111.matrix_multiplication"><code class="name flex">
<span>def <span class="ident">matrix_multiplication</span></span>(<span>m_1: numpy.ndarray, m_2: numpy.ndarray) ‑> numpy.ndarray</span>
</code></dt>
<dd>
<div class="desc"><p>Función que recibe dos matrices numpy de dimensiones compatibles y realiza
una multiplicacion entre ambas.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>m_1</code></strong></dt>
<dd>Matriz 1 </dd>
<dt><strong><code>m_2</code></strong></dt>
<dd>Matriz 2</dd>
</dl>
<p>Return:
result: Matriz resultante de multiplicar la matriz 1 con la matriz 2</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def matrix_multiplication(m_1: np.ndarray, m_2: np.ndarray) -&gt; np.ndarray :
    &#34;&#34;&#34;
    Función que recibe dos matrices numpy de dimensiones compatibles y realiza 
    una multiplicacion entre ambas.
    
    Args:
        m_1: Matriz 1 
        m_2: Matriz 2
    
    Return: 
        result: Matriz resultante de multiplicar la matriz 1 con la matriz 2
    &#34;&#34;&#34;
    result = np.zeros((len(m_1),len(m_1)))
    
    for i in range(len(m_1)):

        for j in range(len(m_2[0])):

            for k in range(len(m_2)):
                result[i][j] += m_1[i][k] * m_2[k][j]

    return result</code></pre>
</details>
</dd>
<dt id="P111.min_heapify"><code class="name flex">
<span>def <span class="ident">min_heapify</span></span>(<span>h: numpy.ndarray, i: int)</span>
</code></dt>
<dd>
<div class="desc"><p>Función que recibe un array de numpy aplica heapify sorbre el elemento situado en el índice indicado como argumento.
Esto es que dado un nodo se asegura que el subárboll desde ese nodo es un min heap.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>h</code></strong></dt>
<dd>Array numpy que contiene el nodo sobre el que se quiere realizar el heapify</dd>
<dt><strong><code>i</code></strong></dt>
<dd>Índice del nodo sobre el que se quiere realizar heapify</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def min_heapify(h: np.ndarray, i: int):
    &#34;&#34;&#34;
    Función que recibe un array de numpy aplica heapify sorbre el elemento situado en el índice indicado como argumento.
    Esto es que dado un nodo se asegura que el subárboll desde ese nodo es un min heap.

    Args:
        h: Array numpy que contiene el nodo sobre el que se quiere realizar el heapify
        i: Índice del nodo sobre el que se quiere realizar heapify
    &#34;&#34;&#34;
    # Mientras no estes en el nodo hoja
    while 2*i+1 &lt; len(h):
        n_i = i

        # Si nodo enviado &gt; que hijo izquierdo entonces guardas posicion hijo
        if h[i] &gt; h[2*i+1]:
            n_i = 2*i+1

        #Comprueba si hay hijo derecho y si lo hay comprueba nodo estamos &gt; derecho y si posicion guardada es &gt; hijo derecho, si ambos son mayores se actualiza posicion&#34;&#34;&#34;
        if 2*i+2 &lt; len(h) and h[i] &gt; h[2*i+2] and h[2*i+2] &lt; h[n_i]:
            n_i = 2*i+2

        #Si no hijo izq y drc es menor, y nodo que hemos guardado tiene valor menor o posicion baja, intercambia valores de i y n_i&#34;&#34;&#34;
        if n_i &gt; i:
            h[i], h[n_i] = h[n_i], h[i]
            i = n_i

        #Si no hace nada, devuelve
        else:
            return</code></pre>
</details>
</dd>
<dt id="P111.obtiene_menores"><code class="name flex">
<span>def <span class="ident">obtiene_menores</span></span>(<span>h: numpy.ndarray) ‑> numpy.ndarray</span>
</code></dt>
<dd>
<div class="desc"><p>Función que encuentra los 2 menores elemento dentro del array pasado por argumento</p>
<p>Args:
h: Array del que se quieren encontrar los 2 menores elementos</p>
<h2 id="return">Return</h2>
<p>Array que contiene los dos menores elementos.
Si el array tiene 2 o menos elementos se devuelven esos elementos.
Si el array pasado por argumento está vacío devuelve None.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def obtiene_menores(h: np.ndarray)-&gt; np.ndarray:
    &#34;&#34;&#34;
    Función que encuentra los 2 menores elemento dentro del array pasado por argumento

    Args: 
        h: Array del que se quieren encontrar los 2 menores elementos
    
    Return:
        Array que contiene los dos menores elementos.
        Si el array tiene 2 o menos elementos se devuelven esos elementos.
        Si el array pasado por argumento está vacío devuelve None.
    &#34;&#34;&#34;

    # si el array tiene 2 o menos elementos se devuelven estos
    if len(h) == 1 or len(h) == 2: return h

    # si esta vacio se devuelve None
    if len(h) == 0 or h is None: return None

    m1 = h[0]
    m2 = h[1]
    for i in range(2, len(h)):
        if m1 &gt; h[i] or m2 &gt; h[i]:
            if m1 &gt; m2:
                m1 = h[i]
            else:
                m2 = h[i]

    return [m1,m2]</code></pre>
</details>
</dd>
<dt id="P111.pq_ini"><code class="name flex">
<span>def <span class="ident">pq_ini</span></span>(<span>) ‑> numpy.ndarray</span>
</code></dt>
<dd>
<div class="desc"><p>Inicializa una cola de prioridad vacía</p>
<h2 id="return">Return</h2>
<p>q: Cola de proiridad vacía</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def pq_ini() -&gt; np.ndarray:
    &#34;&#34;&#34;
    Inicializa una cola de prioridad vacía

    Return:
        q: Cola de proiridad vacía
    &#34;&#34;&#34;

    q = []
    return q</code></pre>
</details>
</dd>
<dt id="P111.pq_insert"><code class="name flex">
<span>def <span class="ident">pq_insert</span></span>(<span>h: numpy.ndarray, k: int) ‑> numpy.ndarray</span>
</code></dt>
<dd>
<div class="desc"><p>Función que inserta el elemento pasado por argumento en la cola de prioridad y devuelve
la nueva cola</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>h</code></strong></dt>
<dd>Cola en la que se quiere insertar el elemento</dd>
<dt><strong><code>k</code></strong></dt>
<dd>Elemento a insertar</dd>
</dl>
<h2 id="return">Return</h2>
<p>Cola de proiridad vacía</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def pq_insert(h: np.ndarray, k: int)-&gt; np.ndarray:
    &#34;&#34;&#34;
    Función que inserta el elemento pasado por argumento en la cola de prioridad y devuelve 
    la nueva cola

    Args:
        h: Cola en la que se quiere insertar el elemento
        k: Elemento a insertar

    Return:
        Cola de proiridad vacía
    &#34;&#34;&#34;
    
    return insert_min_heap(h, k)</code></pre>
</details>
</dd>
<dt id="P111.pq_remove"><code class="name flex">
<span>def <span class="ident">pq_remove</span></span>(<span>h: numpy.ndarray) ‑> numpy.ndarray</span>
</code></dt>
<dd>
<div class="desc"><p>Función que elimina el elemento con el menor valor de prioridad de la cola de prioridad pasada por
argumento.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>h</code></strong></dt>
<dd>Cola de prioridad de la que se quiere eliminar el elemento con menor valor de prioridad</dd>
</dl>
<h2 id="return">Return</h2>
<p>Devuelve el elemento eliminado y la nueva cola.
Si la cola pasada por argumento está vacía devuelve None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def pq_remove(h: np.ndarray)-&gt; np.ndarray:
    &#34;&#34;&#34;
    Función que elimina el elemento con el menor valor de prioridad de la cola de prioridad pasada por 
    argumento.

    Args:
        h: Cola de prioridad de la que se quiere eliminar el elemento con menor valor de prioridad

    Return:
        Devuelve el elemento eliminado y la nueva cola. 
        Si la cola pasada por argumento está vacía devuelve None

    &#34;&#34;&#34;
    #Comprobación
    if h is None or len(h) == 0: return None
    
    elim = h[0]
    h = np.delete(h,0)
    min_heapify(h,0)
    return elim, h</code></pre>
</details>
</dd>
<dt id="P111.rec_bb"><code class="name flex">
<span>def <span class="ident">rec_bb</span></span>(<span>t: list, f: int, l: int, key: int) ‑> int</span>
</code></dt>
<dd>
<div class="desc"><p>Función que recibe una lista con su primer y último indice, asi como una clave a buscar y
aplica una versión recursiva de la búsqueda binaria para encontrar la posición
de la clave(key) entre el indice primero(first) y el indiice último(last).</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>t</code></strong></dt>
<dd>Lista sobre la que se buscará la clave</dd>
<dt><strong><code>f</code></strong></dt>
<dd>Primer índice</dd>
<dt><strong><code>l</code></strong></dt>
<dd>Último índice</dd>
<dt><strong><code>key</code></strong></dt>
<dd>Clave a buscar</dd>
</dl>
<p>Return:
Si encuentra la clave devuelve el índice donde es encontrado, de no encontrarse
la clave devuelve None.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def rec_bb(t: list, f: int, l: int, key: int) -&gt; int :
    &#34;&#34;&#34;
    Función que recibe una lista con su primer y último indice, asi como una clave a buscar y
    aplica una versión recursiva de la búsqueda binaria para encontrar la posición
    de la clave(key) entre el indice primero(first) y el indiice último(last).
    
    Args:
        t: Lista sobre la que se buscará la clave
        f: Primer índice
        l: Último índice
        key: Clave a buscar

    
    Return: 
        Si encuentra la clave devuelve el índice donde es encontrado, de no encontrarse 
        la clave devuelve None.
    &#34;&#34;&#34;
    if l&gt;=f:

        mid = (f+l) // 2

        if t[mid] == key:
            return mid
        
        elif t[mid] &lt; key:
            return rec_bb(t, mid+1, l, key)

        else:
            return rec_bb(t, f, mid-1, key)

    else:
        return None</code></pre>
</details>
</dd>
<dt id="P111.select_min_heap"><code class="name flex">
<span>def <span class="ident">select_min_heap</span></span>(<span>h: numpy.ndarray, k: int) ‑> int</span>
</code></dt>
<dd>
<div class="desc"><p>Función que devuelve el elemento en la posición K pasada por argumento si el array pasado
por argumento estuviera estuveira ordenado de menor a mayor
ejemplo: array = [3,1,2,4,5] ordenado = [1,2,3,4,5] K = 2 entonces numero = 2</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>h</code></strong></dt>
<dd>Array del que se quiere obtener el elemento en la posición K de estar ordenado de menor a mayor</dd>
<dt><strong><code>k</code></strong></dt>
<dd>Posición dentro del array ordenado</dd>
</dl>
<h2 id="return">Return</h2>
<p>Elemento en la posición K dentro del array ordenado</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def select_min_heap(h: np.ndarray, k: int)-&gt; int:
    &#34;&#34;&#34;
    Función que devuelve el elemento en la posición K pasada por argumento si el array pasado 
    por argumento estuviera estuveira ordenado de menor a mayor
    ejemplo: array = [3,1,2,4,5] ordenado = [1,2,3,4,5] K = 2 entonces numero = 2
    
    Args:
        h: Array del que se quiere obtener el elemento en la posición K de estar ordenado de menor a mayor
        k: Posición dentro del array ordenado

    Return:
        Elemento en la posición K dentro del array ordenado

    &#34;&#34;&#34;
    aux = h.copy()
    # invierte el array 
    aux = np.multiply(aux, -1)
    # se cogen los k primeros
    aux_mh = aux[:k]
    
    # realiza el create_min_heap sobre el array invertido
    create_min_heap(aux_mh)

    for i in range (k, len(h)):
        if aux[i] &gt; aux_mh[0]:
            aux_mh[0] = aux[i]
            min_heapify(aux_mh, 0)
    
    return aux_mh[0]*-1</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="P111.bb" href="#P111.bb">bb</a></code></li>
<li><code><a title="P111.create_min_heap" href="#P111.create_min_heap">create_min_heap</a></code></li>
<li><code><a title="P111.insert_min_heap" href="#P111.insert_min_heap">insert_min_heap</a></code></li>
<li><code><a title="P111.matrix_multiplication" href="#P111.matrix_multiplication">matrix_multiplication</a></code></li>
<li><code><a title="P111.min_heapify" href="#P111.min_heapify">min_heapify</a></code></li>
<li><code><a title="P111.obtiene_menores" href="#P111.obtiene_menores">obtiene_menores</a></code></li>
<li><code><a title="P111.pq_ini" href="#P111.pq_ini">pq_ini</a></code></li>
<li><code><a title="P111.pq_insert" href="#P111.pq_insert">pq_insert</a></code></li>
<li><code><a title="P111.pq_remove" href="#P111.pq_remove">pq_remove</a></code></li>
<li><code><a title="P111.rec_bb" href="#P111.rec_bb">rec_bb</a></code></li>
<li><code><a title="P111.select_min_heap" href="#P111.select_min_heap">select_min_heap</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>